= Rest OAuth 2.0 Server

<b>Rest OAuth 2.0 Server</b> is a gem that easily allow the generation of an OAuth 2.0 Server following the {draft 13}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13]
of the OAuth 2.0 protocol with {bearer tokens}[http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-02]. The spec 
is close to settling down, and we intend to update our code to match the final OAuth 2.0 and bearer token standards. 
OAuth has often been described as a "valet key for the web." It lets applications ask users for access to just the 
data they need and no more, giving them the ability to enable and disable the accesses whenever they want, most of 
the time without sharing their secret credentials.

Today Rest OAuth 2.0 Server supports three flows of OAuth 2.0
* The server-side flow for web applications with servers that can securely store persistent information ({Authorization Code Flow}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.1])
* The client-side flow for JavaScript applications running in a browser ({Implicit Grant Flow}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.2]) 
* The native application flow for desktop and mobile applications ({Resource Owner Password Credentials Flow}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.3])


= Installation

For the project to work is required ruby 1.9.2 and MongoDB[http://www.mongodb.org/], which is the default database
system (we use the handy Mondoid[mongoid.org] library to access it). To install it clone the repository, install the
gems with bundler and run the tests. If everything works correctly you will have an OAuth2 server up and running!

  git clone git@github.com:Lelylan/rest-oauth2-server.git
  bundle install
  rake spec

We are working on a gem and a generator to easily integrate the OAuth server into your project. This is the final 
result we want to reach will be something like:

  gem install rest-oauth2-server
  rails g oauth2


= OAuth 2.0 flows

Before diving in the code we want to give an overview on how Rest OAuth2 Server supports the 3 authorization flows. 


== OAuth 2.0 for server-side web applications

This flow is meant for web applications with servers that can keep secrets and maintain state. 

The server-side flow has two parts. In the first part, your application asks the user for permission to access 
their data. If the user approves, instead of sending an access token directly as in the client-side flow, the 
Rest OAuth 2.0 Server will send to the client an authorization code. In the second part, the client will POST 
that code along with its client secret to the Rest OAuth 2.0 Server in order to get the an access token.

=== Getting an access token

This flow begins by sending the user to the authorization endpoint <tt>http://localhost:3000/oauth/authorize</tt>
with the following query parameters

* <b>response_type</b> (REQUIRED): always use "code" as response type
* <b>client_id</b> (REQUIRED): client identifier (the uri of the client model)
* <b>redirect_uri</b> (REQUIRED): callback URI to the client application
* <b>scope</b> (REQUIRED): privileges given to the client
* <b>state</b> (OPTIONAL): opaque value used by the client to maintain state between the request and callback

Here's an example URL for a hypothetical app called "Example App" running on https://www.example.com

  http://localhost:3000/oauth/authorize?
    response_type=code&
    client_id=http://localhost:3000/clients/a918F2fs3&
    redirect_uri=httsp://www.example.com/callback&
    scope=write&
    state=2af5D3vds

After the user approves access or chooses not to, we'll redirect to the <tt>redirect_uri</tt> you pass us. If the 
user denies access, an error code is appended:

  https://example.com/callback?access=denied&state=2af5D3vds

If the user approves access will be appended an authorization code in the query string of the URL:

  https://example.com/callback?code=g2VDXwrT0S6iZeUeYQBYi2stxRy&state=2af5D3vds

Now, the client reached through the <tt>redirect_uri</tt> should swap that authorization code for an access token by POSTing 
it along the following params to the token endpoint <tt>http://localhost:3000/oauth/token</tt> using the JSON format.

* <b>code</b> (REQUIRED): authorization code (from the previous step)
* <b>grant_type</b> (REQUIRED): always use "authorization_code" as grant type
* <b>client_id</b> (REQUIRED): client identifier (in our case is the uri field of the client)
* <b>client_secred</b> (REQUIRED): client secret code

Using curl the request might look like:
 
  curl -i http://localhost:3000/oauth/token \
       -H "Accept: application/json" \
       -X POST -d '{
          "code": "g2VDXwrT0S6iZeUeYQBYi2stxRy", \
          "grant_type": "authorization_code", \
          "client_id": "http://localhost:30000/clients/a918F2fs3", \
          "client_secret": "a34a7afe4731e745de9d61iZeUeY", \
          "scope": "write"
       }'

The response is a JSON Object containing the access token:

  { "access_token":"SlAV32hkKG" }



== OAuth 2.0 for client-side web applications

This flow is meant for JavaScript-based web applications that can't maintain state over time (it includes also ActionScript 
and SilverLight).

=== Getting a user's permission


This flow begins by sending the user to the authorization endpoint <tt>http://localhost:3000/oauth/authorize</tt>
with the following query parameters

* <b>response_type</b> (REQUIRED): always use "token" as response type
* <b>client_id</b> (REQUIRED): client identifier (the uri of the client model)
* <b>redirect_uri</b> (REQUIRED): callback URI to the client application
* <b>scope</b> (REQUIRED): privileges given to the client
* <b>state</b> (OPTIONAL): opaque value used by the client to maintain state between the request and callback

Here's an example URL for a hypothetical app called "Example App" running on https://www.example.com

  http://localhost:3000/oauth/authorize?
    response_type=token&
    client_id=http://localhost:3000/clients/a918F2fs3&
    redirect_uri=httsp://www.example.com/callback&
    scope=write&
    state=2af5D3vds

After the user approves access or chooses not to, we'll redirect to the <tt>redirect_uri</tt> you pass. If the 
user denies access, an error code is appended:

  https://example.com/callback#access=denied&state=2af5D3vds

If the user approves will be appended an access token in the hash fragment of the UR:

  https://example.com/callback#token=g2VDXwrT0S6iZeUeYQBYi2stxRy&state=2af5D3vds

JavaScript running on that page can grab that access token from the <tt>window.location.hash</tt> and either store it in a
cookie or POST it to a server. Note that the token is added to the {fragment URI}[http://en.wikipedia.org/wiki/Fragment_identifier]. 
This is done because the fragment URI can not be read from server side, but only from client-based applications.



== OAuth 2.0 for native applications

This flow is meant for mobile, and desktop installed applications that want access to user data (native apps).

This flow is suitable in cases where the resource owner has a trust relationship with the client, such as its computer operating 
system or a highly privileged application. The authorization server should take special care when enabling the grant type, and 
<b>only when other flows are not viable</b>, because username and password are shared with the client.

=== Getting an access token

The client should POST to the token endpoint <tt>http://localhost:3000/oauth/token</tt> along with the following params
using the JSON format:

* <b>grant_type</b> (REQUIRED): always use "password" as grant type
* <b>username</b> (REQUIRED): resource owner email address
* <b>password</b> (REQUIRED): resource owner password
* <b>client_id</b> (REQUIRED): client identifier (the uri of the client model)
* <b>redirect_uri</b> (REQUIRED): callback URI to the client application
* <b>scope</b> (REQUIRED): privileges given to the client

Using curl the request might look like:

  curl -i http://localhost:3000/oauth/token \
       -H "Accept: application/json" \
       -X POST -d '{
          "grant_type": "password", \
          "client_id": "http://localhost:3000/clients/a918F2fs3", \
          "client_secret": "a34a7afe4731e745de9d61iZeUeY", \
          "username": "alice@example.com", \
          "password": "example", \
          "scope": "write"
       }'
       
The response is a JSON Object containing the access token:

  { "access_token":"SlAV32hkKG" }



= Models

Rest OAuth 2.0 Server is working on top of 5 models. They are pretty simple so if you want to have more information about
them, check the source code, which is clearly documented.

* {OauthClient}[link:blob/master/app/models/oauth/oauth_client.rb]: represents the credentials of a client application.
* {OauthToken}[link:blob/master/app/models/oauth/oauth_token.rb]: represents the token used to access user's resources.
* {OauthAuthorizarion}[link:blob/master/app/models/oauth/oauth_authorization.rb]: represents the authorization token used to exchange an access token.
* {OauthAccess}[link:blob/master/app/models/oauth/oauth_access.rb]: represents the relation between a client and a user, whenever a user grant an authorization.
* {OauthDailyRequests}[link:blob/master/app/models/oauth/oauth_daily_request.rb]: represents a daily request from the client on behalf of a specific user.

In addition to the models above, there is a basic {User}[link:app/models/user.rb] model which defines the basic authentication 
system (together with {users_controller}[blob/master/app/controllers/users_controller.rb] and {sessions_controller}[blob/master/app/controllers/sessions_controller.rb]). 
This model is kept simple on porpuse, but you can easily change it with the authentication system you prefer, like {Authlogic}[https://github.com/binarylogic/authlogic] 
or {Devise}[https://github.com/plataformatec/devise]. Just remember that your user model <b>must</b> define an <tt>uri</tt> field.

= Blocking System




= Testing solutions


= Other OAuth2 documentation

If the way OAuth2 works is not clear, you can find great documentation on the web.

* {Oauth2 Specifications}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13]
* {Google OAuth2}[http://code.google.com/apis/accounts/docs/OAuth2.html]
* {Facebook OAuth2}[http://developers.facebook.com/docs/authentication]
* {Gowalla OAuth2}[http://gowalla.com/api/docs/oauth]
* {Foursquare OAuth2}[http://developer.foursquare.com/docs/oauth.html]
* {Instagram OAuth2}[http://instagram.com/developer/auth/]



= Other OAuth2 Ruby Implementations

* {Flowtown Rack OAuth2 Server}[https://github.com/flowtown/rack-oauth2-server]
* {Nov Rack OAuth2}[https://github.com/nov/rack-oauth2]
* {ThoughWorks OAuth2 Provider}[https://github.com/ThoughtWorksStudios/oauth2_provider]
* {Freerange OAuth2 Provider}[https://github.com/freerange/oauth2-provider/blob/master/lib/oauth2/provider/models/access_token.rb]



= Author

Andrea Reginato & The Lelylan Project

A special thanks to the OAuth 2.0 specification team, to the Flowtown Rack Oauth2 Server which gave the 
initial bases of the project and to Google OAuth 2.0 specification which are so clear to understand.

= TODOs

* Implement refresh token flow 
* Add scope definition



= Changelog

See CHANGELOG



= License

Rest OAuth2 Server is available under the MIT license.
