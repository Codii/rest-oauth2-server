= Rest OAuth 2.0 Server

<b>Rest OAuth 2.0 Server</b> is a gem that easily allow the generation of an OAuth 2.0 Server following the {draft 13}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13]
of the OAuth 2.0 protocol with {bearer tokens}[http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-02]. The spec 
is close to settling down, and we intend to update our code to match the final OAuth 2.0 and bearer token standards. 
OAuth has often been described as a "valet key for the web." It lets applications ask users for access to just the 
data they need and no more, giving them the ability to enable and disable the accesses whenever they want, most of 
the time without sharing their secret credentials.

Today Rest OAuth 2.0 Server supports three flows of OAuth 2.0
* The server-side flow for web applications with servers that can securely store persistent information ({Authorization Code Flow}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.1])
* The client-side flow for JavaScript applications running in a browser ({Implicit Grant}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.2]) 
* The native application flow for desktop and mobile applications ({Resource Owner Password Credentials}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.3])


= Installation

For the project to work you is required ruby 1.9.2 and MongoDB[http://www.mongodb.org/] which is the default database
system (we use the handy Mondoid[mongoid.org] library to access it). To install it clone the repository, install the
gems with bundler and run the tests. If everything works correctly, you have your OAuth2 server up and running.

  git clone git@github.com:Lelylan/rest-oauth2-server.git
  bundle install
  rake spec

We are working on a gem and a generator to easily integrate the OAuth server into your project. This is the final 
result we want to reach.

  gem install rest-oauth2-server
  rails g oauth2


= OAuth 2.0 flows

Before diving in the code, we explain how Rest OAuth2 Server supports the 3 authorization flows. 


== Authorization Code Flow (aka OAuth2 for server side app)

The {Authorization Code}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.1] is suitable for
clients capable of maintaining their client credentials confidential (for authenticating with the authorization
server) such as a client implemented on a <b>secure server side</b>. As a redirection-based flow, the client must
be capable of interacting with typically a web browser and capable of receiving incoming requests from the
authorization server. In greater detail, the authorization flow goes like this.


=== Authorization Code

The client construct the redirect URI to your {authorization endpoint}[http://localhost:3000/oauth/authorize] by adding the
following parameters in the query component (to create a client go to the rails console and type Factory(:oauth_client),
soon there will be a UI where you will be able to easily create your clients)

  GET http://localhost:3000/oauth/authorize?
      response_type=code&
      client_id=http://localhost:3000/users/alic/clients/example&
      redirect_uri=http://example.com/callback&
      scope=write&
      state=2af5D3vds

Lets explain in detail the {authorization request}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.1.1] params

* <b>response_type</b> (REQUIRED): always use "code" as response type
* <b>client_id</b> (REQUIRED): client identifier (in our case is the uri field of the client model)
* <b>redirect_uri</b> (REQUIRED): callback URI to the client application
* <b>scope</b> (REQUIRED): privileges given to the client (TODO: make section)
* <b>state</b> (OPTIONAL): opaque value used by the client to maintain state between the request and callback

In the authorization page the resource owner will be asked to grand or deny the access to the specific client for
a specif scope. If the resource owner 'grant' the access, the client will get back an authorization code that will
be used in a second step to have the access token, otherwise an error will be sent.

  # The resource owner grants the access request
  https://example.com/callback?code=g2VDXwrT0S6iZeUeYQBYi2stxRy&state=2af5D3vds

  # The resource owner denies the access request
  https://example.com/callback?access=denied&state=2af5D3vds


=== Access Token

Supposing the resource owner grant the access request, the client uses the authorization code to get the {access token}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.1.3].
This is done by making a POST request to the /oauth/token resource and by sending the following params in the JSON format.

  curl -i http://localhost:3000/oauth/token \
       -H "Accept: application/json" \
       -X POST -d \ '{
          "code": "g2VDXwrT0S6iZeUeYQBYi2stxRy", \
          "grant_type": "authorization_code", \
          "client_id": "http://localhost:3000/users/alice/client/lelylan", \
          "client_secret": "a34a7afe4731e745de9d61iZeUeY", \
          "scope": "write" }'

Lets explain in detail the {Access Token Request}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.1.3] params

* <b>code</b> (REQUIRED): authorization code (from the previous step)
* <b>grant_type</b> (REQUIRED): always use "authorization_code" as grant type
* <b>client_id</b> (REQUIRED): client identifier (in our case is the uri field of the client)
* <b>client_secred</b> (REQUIRED): client secret code

The response is a JSON structure containing the final access token.

  { "access_token":"SlAV32hkKG" }

We are working on the definition of a refresh token mechanism to improve the OAuth security system




== OAuth 2.0 for client-side web applications

This flow is meant for JavaScript-based web applications that can't maintain state over time. For those who prefer to send 
and receive HTTP directly without using a client library, this section walks through how to use OAuth 2.0 for client-side 
web applications (it includes also ActionScript and SilverLight).

=== Getting a user's permission

Every flow of OAuth 2.0 begins by sending the user to our OAuth dialog at the authorization endpoint <tt>[http://localhost:3000/oauth/authorize</tt>
with the following query parameters

* <b>response_type</b> (REQUIRED): always use "token" as response type
* <b>client_id</b> (REQUIRED): client identifier (in our case is the uri field of the client model)
* <b>redirect_uri</b> (REQUIRED): callback URI to the client application
* <b>scope</b> (REQUIRED): privileges given to the client (TODO: make section)
* <b>state</b> (OPTIONAL): opaque value used by the client to maintain state between the request and callback

Here's an example URL for a hypothetical app called "Example App" running on https://www.example.com

  http://localhost:3000/oauth/authorize?
    response_type=token&
    client_id=http://localhost:3000/clients/a918F2fs3&
    redirect_uri=httsp://www.example.com/callback&
    scope=write&
    state=2af5D3vds

After the user approves access or chooses not to, we'll redirect to the <tt>redirect_uri</tt> you pass us. If the 
user denies access, an error code is appended:

  https://example.com/callback#access=denied&state=2af5D3vds

If the user approves access we'll append a short-lived access token in the hash fragment of the URL. Access tokens 
typically are valid for a bit more than an hour, but implementations shouldn't depend on that behavior. In the example 
above, your browser should be redirected to something like:

  https://example.com/callback#token=g2VDXwrT0S6iZeUeYQBYi2stxRy&state=2af5D3vds

JavaScript running on that page can grab that access token from the window.location.hash and either store it in a cookie 
or POST it to a server. Note that the token is added to the {fragment URI}[http://en.wikipedia.org/wiki/Fragment_identifier]. 
This is done because the fragment URI can not be read from server side, but only from client.based applications


== Resource Owner Password Credentials Flow (aka OAuth2 for native app)

The {Resource Owner Password Credential}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.3] flow is suitable
in cases where the resource owner has a trust relationship with the client, such as its computer operating system or a
highly privileged application. The authorization server should take special care when enabling the grant type, and <b>only
when other flows are not viable</b>.

To have the access token the client make a POST request to the /oauth/token resource by sending the username and password
given from the resource owner, plus the following params in the JSON format.

  curl -i http://localhost:3000/oauth/token \
       -H "Accept: application/json" \
       -X POST -d \ '{
          "grant_type": "password", \
          "client_id": "http://localhost:3000/users/alice/client/lelylan", \
          "client_secret": "a34a7afe4731e745de9d61iZeUeY", \
          "username": "alice@example.com", \
          "password": "example", \
          "scope": "write" }'


* <b>grant_type</b> (REQUIRED): always use "password" as grant type
* <b>client_id</b> (REQUIRED): client identifier (in our case is the uri field of the client model)
* <b>redirect_uri</b> (REQUIRED): callback URI to the client application
* <b>username</b> (REQUIRED): resource owner username
* <b>password</b> (REQUIRED): resource owner password
* <b>scope</b> (REQUIRED): privileges given to the client (TODO: make section)

The response is a JSON structure containing the final access token.

  { "access_token":"SlAV32hkKG" }

We are working on the definition of a refresh token mechanism to improve the OAuth security system


= OAuth2 documentation

If the way OAuth2 works is not clear, you can find great documentation on the web.

* {Oauth2 Specifications}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13]
* {Google OAuth2}[http://code.google.com/apis/accounts/docs/OAuth2.html]
* {Facebook OAuth2}[http://developers.facebook.com/docs/authentication]
* {Gowalla OAuth2}[http://gowalla.com/api/docs/oauth]
* {Foursquare OAuth2}[http://developer.foursquare.com/docs/oauth.html]
* {Instagram OAuth2}[http://instagram.com/developer/auth/]


= Other OAuth2 Ruby Implementations

* {Flowtown Rack OAuth2 Server}[https://github.com/flowtown/rack-oauth2-server]
* {Nov Rack OAuth2}[https://github.com/nov/rack-oauth2]
* {ThoughWorks OAuth2 Provider}[https://github.com/ThoughtWorksStudios/oauth2_provider]
* {Freerange OAuth2 Provider}[https://github.com/freerange/oauth2-provider/blob/master/lib/oauth2/provider/models/access_token.rb]

= Author

Andrea Reginato & The Lelylan Project


= Changelog

See CHANGELOG


= License

Rest OAuth2 Server is available under the MIT license.
