= TODO DOCUMENTATION

* Explain how scope works and how it can daynamically be set
* Explain where the tests are and the tech used
* Integrate the flow description with some code
* Explain how to protect a resource (bearer token)


= Rest OAuth 2.0 Server

<b>Rest OAuth 2.0 Server</b> is a gem that easily allow the generation of an OAuth 2.0 Server following the {draft 13}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13]
of the OAuth 2.0 protocol with {bearer tokens}[http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-02]. The spec 
is close to settling down, and we intend to update our code to match the final OAuth 2.0 and bearer token standards. 
OAuth has often been described as a "valet key for the web." It lets applications ask users for access to just the 
data they need and no more, giving them the ability to enable and disable the accesses whenever they want, most of 
the time without sharing their secret credentials.

Today Rest OAuth 2.0 Server supports three flows of OAuth 2.0
* The server-side flow for web applications with servers that can securely store persistent information ({Authorization Code Flow}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.1])
* The client-side flow for JavaScript applications running in a browser ({Implicit Grant Flow}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.2]) 
* The native application flow for desktop and mobile applications ({Resource Owner Password Credentials Flow}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.3])



= OAuth 2.0 flows explained

Before diving into the code we want to give an overview on how Rest OAuth 2.0 Server supports the 3 authorization flows.

== OAuth 2.0 for server-side web applications

This flow is meant for web applications with servers that can keep secrets and maintain state. 

The server-side flow has two parts. In the first part, your application asks the user for permission to access 
their data. If the user approves, instead of sending an access token directly as in the client-side flow, the 
Rest OAuth 2.0 Server will send to the client an authorization code. In the second part, the client will POST 
that code along with its client secret to the Rest OAuth 2.0 Server in order to get the access token.

=== Getting an access token

This flow begins by sending the user to the authorization endpoint <tt>http://localhost:3000/oauth/authorization</tt>
with the following query parameters

* <b>response_type</b> (REQUIRED): always use "code" as response type
* <b>client_id</b> (REQUIRED): client identifier (the URI of the client model)
* <b>redirect_uri</b> (REQUIRED): callback URI to the client application
* <b>scope</b> (REQUIRED): privileges given to the client
* <b>state</b> (OPTIONAL): opaque value used by the client to maintain state between the request and callback

Here's an example URL for a hypothetical app called "Example App" running on https://www.example.com

  http://localhost:3000/oauth/authorization?
    response_type=code&
    client_id=http://localhost:3000/clients/a918F2fs3&
    redirect_uri=httsp://www.example.com/callback&
    scope=write&
    state=2af5D3vds

After the user approves access or chooses not to, we'll redirect to the <tt>redirect_uri</tt> you pass us. If the 
user denies access, an error code is appended:

  https://example.com/callback?error=access_denied&state=2af5D3vds

If the user approves access will be appended an authorization code in the query string of the URL:

  https://example.com/callback?code=g2VDXwrT0S6iZeUeYQBYi2stxRy&state=2af5D3vds

Now, the client reached through the <tt>redirect_uri</tt> should swap that authorization code for an access token by POSTing 
it along the following params to the token endpoint <tt>http://localhost:3000/oauth/token</tt> using the JSON format.

* <b>code</b> (REQUIRED): authorization code (from the previous step)
* <b>grant_type</b> (REQUIRED): always use "authorization_code" as grant type
* <b>client_id</b> (REQUIRED): client identifier (in our case is the uri field of the client)
* <b>client_secred</b> (REQUIRED): client secret code

Using curl the request might look like:
 
  curl -i http://localhost:3000/oauth/token \
       -H "Accept: application/json" \
       -X POST -d '{
          "code": "g2VDXwrT0S6iZeUeYQBYi2stxRy", \
          "grant_type": "authorization_code", \
          "client_id": "http://localhost:30000/clients/a918F2fs3", \
          "client_secret": "a34a7afe4731e745de9d61iZeUeY" \
       }'

The response is a JSON Object containing the access token:

  { 
    "access_token": "SlAV32hkKG", 
    "expires_in": 1800,
    "refresh_token": "Da8i1930LSj"
  }

=== Getting additional access tokens

When your access token expires, Rest OAuth 2.0 Server API endpoints will respond with HTTP 401 Unauthorized. At any time, 
you can use the token endpoint with your refresh token with the following query parameters

* <b>grant_type</b> (REQUIRED): always use "refresh_token" as grant type
* <b>client_id</b> (REQUIRED): client identifier (in our case is the uri field of the client)
* <b>client_secred</b> (REQUIRED): client secret code
* <b>refresh_token</b> (REQUIRED): refresh token previusly received

Using curl the request might look like:
 
  curl -i http://localhost:3000/oauth/token \
       -H "Accept: application/json" \
       -X POST -d '{
          "grant_type": "refresh_token", \
          "refresh_token": "Da8i1930LSj", \
          "client_id": "http://localhost:30000/clients/a918F2fs3", \
          "client_secret": "a34a7afe4731e745de9d61iZeUeY" \
       }'

The response is a JSON Object containing the new access token. 

  { 
    "access_token": "AlYZ892hsKs", 
    "expires_in": 1800,
    "refresh_token": "Da8i1930LSj"
  }

=== Going deep

If you are curious and you want to find more check the {acceptance}[link:blob/development/spec/acceptance/oauth/oauth_authorize_controller_spec.rb] 
{tests}[link:blob/development/spec/acceptance/oauth/oauth_token_controller_spec.rb] in the <b>Authorization token 
flow</b> and <b>refresh token</b> context.



== OAuth 2.0 for client-side web applications

This flow is meant for JavaScript-based web applications that can't maintain state over time (it includes also ActionScript 
and SilverLight).

=== Getting a user's permission


This flow begins by sending the user to the authorization endpoint <tt>http://localhost:3000/oauth/authorization</tt>
with the following query parameters

* <b>response_type</b> (REQUIRED): always use "token" as response type
* <b>client_id</b> (REQUIRED): client identifier (the uri of the client model)
* <b>redirect_uri</b> (REQUIRED): callback URI to the client application
* <b>scope</b> (REQUIRED): privileges given to the client
* <b>state</b> (OPTIONAL): opaque value used by the client to maintain state between the request and callback

Here's an example URL for a hypothetical app called "Example App" running on https://www.example.com

  http://localhost:3000/oauth/authorization?
    response_type=token&
    client_id=http://localhost:3000/clients/a918F2fs3&
    redirect_uri=httsp://www.example.com/callback&
    scope=write&
    state=2af5D3vds

After the user approves access or chooses not to, we'll redirect to the <tt>redirect_uri</tt> you pass. If the 
user denies access, an error code is appended:

  https://example.com/callback#error=access_denied&state=2af5D3vds

If the user approves will be appended an access token in the hash fragment of the UR:

  https://example.com/callback#token=g2VDXwrT0S6iZeUeYQBYi2stxRy&expires_in=1800&state=2af5D3vds

JavaScript running on that page can grab that access token from the <tt>window.location.hash</tt> and either store it in a
cookie or POST it to a server. Note that the token is added to the {fragment URI}[http://en.wikipedia.org/wiki/Fragment_identifier]. 
This is done because the fragment URI can not be read from server side, but only from client-based applications.

=== Getting additional access tokens

When your access token expires, our API endpoints will respond with HTTP 401 Unauthorized. At any time, you can send 
your user to the same authorization endpoint you used in the previous step. If the user has already authorized your 
application for the scopes you're requesting, Rest OAuth Server won't show the OAuth dialog and will immediately redirect 
to the <tt>redirect_uri</tt> you pass us with a new access token.

=== Going deep

If you are curious and you want to find more check the {acceptance tests}[link:/blob/master/spec/acceptance/oauth/oauth_authorize_controller_spec.rb] 
in the <b>implicit token flow</b> and <b>refresh implicit token flow</b>context.



== OAuth 2.0 for native applications

This flow is meant for mobile, and desktop installed applications that want access to user data (native apps).

This flow is suitable in cases where the resource owner has a trust relationship with the client, such as its computer operating 
system or a highly privileged application. The authorization server should take special care when enabling the grant type, and 
<b>only when other flows are not viable</b>, because username and password are shared with the client.

=== Getting an access token

The client should POST to the token endpoint <tt>http://localhost:3000/oauth/token</tt> along with the following params
using the JSON format:

* <b>grant_type</b> (REQUIRED): always use "password" as grant type
* <b>username</b> (REQUIRED): resource owner email address
* <b>password</b> (REQUIRED): resource owner password
* <b>client_id</b> (REQUIRED): client identifier (the uri of the client model)
* <b>redirect_uri</b> (REQUIRED): callback URI to the client application
* <b>scope</b> (REQUIRED): privileges given to the client

Using curl the request might look like:

  curl -i http://localhost:3000/oauth/token \
       -H "Accept: application/json" \
       -X POST -d '{
          "grant_type": "password", \
          "client_id": "http://localhost:3000/clients/a918F2fs3", \
          "client_secret": "a34a7afe4731e745de9d61iZeUeY", \
          "username": "alice@example.com", \
          "password": "example", \
          "scope": "write" \
       }'
       
The response is a JSON Object containing the access token:

  { 
    "access_token": "AlYZ892hsKs", 
    "expires_in": 1800,
    "refresh_token": "Da8i1930LSj"
  }

=== Getting additional access tokens

When your access token expires, Rest OAuth 2.0 Server API endpoints will respond with HTTP 401 Unauthorized. At any time, 
you can use the token endpoint with your refresh token with the following query parameters

* <b>grant_type</b> (REQUIRED): always use "refresh_token" as grant type
* <b>client_id</b> (REQUIRED): client identifier (in our case is the uri field of the client)
* <b>client_secred</b> (REQUIRED): client secret code
* <b>refresh_token</b> (REQUIRED): refresh token previusly received

Using curl the request might look like:
 
  curl -i http://localhost:3000/oauth/token \
       -H "Accept: application/json" \
       -X POST -d '{
          "grant_type": "refresh_token", \
          "refresh_token": "Da8i1930LSj", \
          "client_id": "http://localhost:30000/clients/a918F2fs3", \
          "client_secret": "a34a7afe4731e745de9d61iZeUeY" \
       }'

The response is a JSON Object containing the new access token. 

  { 
    "access_token": "AlYZ892hsKs", 
    "expires_in": 1800,
    "refresh_token": "Da8i1930LSj"
  }

=== Going deep

If you are curious and you want to find more check the {acceptance tests}[link:blob/development/spec/acceptance/oauth/oauth_token_controller_spec.rb] 
in the <b>password credentials flow/b> and <b>refresh token</b> context.




= Installation

For the Rest OAuth 2.0 Server to work you must have installed: 

* {Ruby 1.9.2}[www.ruby-lang.org/en/] 
* {MongoDB}[http://www.mongodb.org/]. 

Once this is done follows these steps:

  # run MongoDB server
  $ mongod  

  # clone the repository
  $ git clone git@github.com:Lelylan/rest-oauth2-server.git

  # install gems
  $ bundle install

  # run test suite
  $ rake spec</tt>

  # run Rest OAuth 2.0 Server
  $ rails s




We are working at a gem and a generator to easily integrate the Rest OAuth 2.0 server into your project, so any 
idea or help will be more than appreciated.

== Scopes definition

The Rest OAuth 2.0 Server ships with an and highly customizable "scope system" which restricts what resources 
a given user can grant to the client applications. 

The Rest OAuth 2.0 Server ships with two sample resources called <tt>pizza</tt> and <tt><pasta></tt>. Each 
resource has the 5 usual REST actions <tt>index</tt>, <tt>show</tt>, <tt>create</tt> , <tt>update</tt> and 
<tt>destroy</tt>. To access this resources, the client usually send a scope, which identify the privileges 
that the user can give. So, lets suppose we want to define two basic scopes:

* <tt>read</tt> which allow the access to the read-only actions <tt>index</tt> and <tt>show</tt>
* <tt>all</tt> which allow the access to all actions

To do this we need to follow two simple steps which we are going to explain in detail.

* Scope administration (only admin user can do this)
* Resource protection (inside every controller)

=== Scope administration

The scope definition consists in the creation of key/actions pairs. In other words, we associate a key to a 
list of accessible actions. To do this you need to log in as admin, open a browser and reach the /scopes 
section.

For example, if you want to define a scope <b>read</b> which allows clients to grant authorization for read-only
actions you need to define a record with an alphanumeric key and a white space list of actions you can access.

* key:    <tt>read</tt>
* values: <tt>pizzas/index pizzas/show pastas/index pastas/show</tt>

Here the only rule to remember is that the values list is separated from spaces and that every value follow a 
convention where you put the <b>controller name</b>, the <b>dash "/"</b> and the <b>action name</b>.

To define the <b>all</b> scope the logic is the same. The only difference is that the scope engine allow you to 
reuse scope keys instead of rewriting all actions. This means that if you want to define a scope to access all 
of the controller actions, you can use <tt>read</tt> to include read-only actions and then add all others. Here 
a sample.

* name:   <tt>all</tt>
* values: <tt>read pizzas/create pizzas/update pizzas/destroy pastas/create pastas/update pastas/destroy</tt>

Look at the {tests}[link:/blob/development/spec/extras/scope_spec.rb] to fully understand the scope engine.

=== Resource protection

Once scopes are defined, you need to add one single line to the controllers you need to protect.

  class PizzasController < ApplicationController
    before_filter :oauth_authorized
    ...

  class PastasController < ApplicationController
    before_filter :oauth_authorized
    ...

This filter verify the authorization to all actions on a controller, based on the scope access a client requires. 
Remember that using the <tt>before_filter</tt> options, you can exclude some actions (making them public) or add 
any logic you need. For example if we want to make the index action public, we simply exclude the action.

   before_filter :oauth_authorized, except: "index"

You can also decide to verify authorizations for all actions that accept the JSON format by uncommenting
<tt>oauth_authorized</tt> in the {ApplicationController}[https://github.com/Lelylan/rest-oauth2-server/blob/development/app/controllers/application_controller.rb]


== Client definition

Before a client application can request access, you must create it. Every registered user have a dashboard where
is possible to create new clients. Registration provides the client application with a client ID and secret. The 
client uses these to authenticate itself, as described in the section <b>OAuth 2.0 flows explained</b>. To create 
it open a browser, login with your credentials and click on the <b>clients</b> link and fill the needed fields. At 
this point you have all you need to use your Rest OAuth 2.0 Server.



= OAuth 2.0 options

Rest OAuth 2.0 Server allows you to personalize some options changing {oauth.yml}[link:blob/master/config/oauth.yml]

* <b>token_expires_in</b>: define the seconds after which the access token expires. 
* <b>authorization_expires_in</b>: define the seconds after which the authorization code expires. 
* <b>secure_random</b>: define the lenght of tokens, code and secret keys.
* <b>scope_separator</b>: define the separator used between different scope keys.



= OAuth 2.0 Models

Rest OAuth 2.0 Server is working on top of 5 models. They are pretty simple so if you want to have more information about
them, check the source code, which is clearly documented.

* {OauthClient}[link:blob/master/app/models/oauth/oauth_client.rb]: represents the credentials of a client application.
* {OauthToken}[link:blob/master/app/models/oauth/oauth_token.rb]: represents the token used to access user's resources.
* {OauthAuthorizarion}[link:blob/master/app/models/oauth/oauth_authorization.rb]: represents the authorization token used to exchange an access token.
* {OauthAccess}[link:blob/master/app/models/oauth/oauth_access.rb]: represents the relation between a client and a user, whenever a user grant an authorization.
* {OauthDailyRequests}[link:blob/master/app/models/oauth/oauth_daily_request.rb]: represents a daily request from the client on behalf of a specific user.


= Basic auth system

In addition to the models above there is a basic authentication system

* {User}[link:blob/master/app/models/user.rb]: represents the basic user authentication functionalities
* {UsersController}[blob/master/app/controllers/users_controller.rb]: represents the user definition
* {SessionsController}[blob/master/app/controllers/sessions_controller.rb]: represents the session definition

This model is kept simple on porpuse, but you can easily change it with the authentication system you prefer like {Authlogic}[https://github.com/binarylogic/authlogic],
{Devise}[https://github.com/plataformatec/devise] or {Warden}[https://github.com/hassox/warden]. Just remember that your user model <b>must</b> 
define an <tt>uri</tt> field, which is used as identifier on the OAuth 2.0 flows.



= Blocking System

One important feature lie in the ability of to block a client. Rest OAuth 2.0 server enables you two possibilities:

* <b>Client block</b> via <tt>client.block!</tt>: used to block a not safe client for all users.
* <b>User block a client</b> via <tt>access.block!</tt>: used when a user want to revoke any access to his resources to a specific client.
* <b>User block an access token</b> via <tt>token.block!</tt>: used when a user logout from the client and want to revoke the token access.

In the first two cases it is possible to unblock the client using the <tt>unblock!</tt> method.



= Testing solutions

The tests are made using {Steak}[https://github.com/cavalle/steak], {Capybara}[https://github.com/jnicklas/capybara] 
and {RSpec}[https://github.com/rspec/rspec-rails]. If you want to know more check the tests on the {models}[https://github.com/Lelylan/rest-oauth2-server/tree/development/spec/models]
and the [acceptance tests]{https://github.com/Lelylan/rest-oauth2-server/tree/development/spec/acceptance} for the controllers
and the views.



= Other OAuth2 documentation

If the way OAuth2 works is not clear, you can find great documentation on the web.

* {Oauth2 Specifications}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13]
* {Google OAuth2}[http://code.google.com/apis/accounts/docs/OAuth2.html]
* {Facebook OAuth2}[http://developers.facebook.com/docs/authentication]
* {Gowalla OAuth2}[http://gowalla.com/api/docs/oauth]
* {Foursquare OAuth2}[http://developer.foursquare.com/docs/oauth.html]
* {Instagram OAuth2}[http://instagram.com/developer/auth/]



= Other OAuth2 Ruby Implementations

* {Flowtown Rack OAuth2 Server}[https://github.com/flowtown/rack-oauth2-server]
* {Nov Rack OAuth2}[https://github.com/nov/rack-oauth2]
* {ThoughWorks OAuth2 Provider}[https://github.com/ThoughtWorksStudios/oauth2_provider]
* {Freerange OAuth2 Provider}[https://github.com/freerange/oauth2-provider/blob/master/lib/oauth2/provider/models/access_token.rb]



= Author

Andrea Reginato & The Lelylan Project

A special thanks to the OAuth 2.0 specification team, to the Flowtown Rack Oauth2 Server which gave the 
initial bases of the project and to Google OAuth 2.0 specification which are so clear to understand.

= TODOs

* Implement refresh token flow 
* Add scope definition



= Changelog

See CHANGELOG



= License

Rest OAuth2 Server is available under the MIT license.
