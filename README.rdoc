= Rest OAuth 2.0 Server

<b>Rest OAuth 2.0 Server</b> is a gem that easily allow the generation of an OAuth 2.0 Server following the {draft 13}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13]
of the OAuth 2.0 protocol with {bearer tokens}[http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-02]. The spec 
is close to settling down, and we intend to update our code to match the final OAuth 2.0 and bearer token standards. 
OAuth has often been described as a "valet key for the web." It lets applications ask users for access to just the 
data they need and no more, giving them the ability to enable and disable the accesses whenever they want, most of 
the time without sharing their secret credentials.

Today Rest OAuth 2.0 Server supports three flows of OAuth 2.0
* The server-side flow for web applications with servers that can securely store persistent information ({Authorization Code Flow}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.1])
* The client-side flow for JavaScript applications running in a browser ({Implicit Grant}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.2]) 
* The native application flow for desktop and mobile applications ({Resource Owner Password Credentials}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.3])


= Installation

For the project to work you is required ruby 1.9.2 and MongoDB[http://www.mongodb.org/] which is the default database
system (we use the handy Mondoid[mongoid.org] library to access it). To install it clone the repository, install the
gems with bundler and run the tests. If everything works correctly, you have your OAuth2 server up and running.

  git clone git@github.com:Lelylan/rest-oauth2-server.git
  bundle install
  rake spec

We are working on a gem and a generator to easily integrate the OAuth server into your project. This is the final 
result we want to reach.

  gem install rest-oauth2-server
  rails g oauth2


= OAuth 2.0 flows

Before diving in the code, we explain how Rest OAuth2 Server supports the 3 authorization flows. 


== OAuth 2.0 for server-side web applications

This flow is meant for web applications with servers that can keep secrets and maintain state. For those who 
prefer to send and receive HTTP directly without using a client library, this section walks through how to use 
OAuth 2.0 for server-side web applications. 

The server-side flow has two parts. In the first part, your application asks the user for permission to access 
their data. If the user approves, instead of sending an access token directly as in the client-side flow, the 
Rest OAuth 2.0 Server will send your application an authorization code. In the second part, your application will 
POST that code along with its client secret to the Rest OAuth 2.0 Server in order to get the an access token

=== Getting an access token

This flow begins by sending the user to our OAuth dialog at the authorization endpoint <tt>http://localhost:3000/oauth/authorize</tt>
with the following query parameters

* <b>response_type</b> (REQUIRED): always use "code" as response type
* <b>client_id</b> (REQUIRED): client identifier (in our case is the uri field of the client model)
* <b>redirect_uri</b> (REQUIRED): callback URI to the client application
* <b>scope</b> (REQUIRED): privileges given to the client (TODO: make section)
* <b>state</b> (OPTIONAL): opaque value used by the client to maintain state between the request and callback

Here's an example URL for a hypothetical app called "Example App" running on https://www.example.com

  http://localhost:3000/oauth/authorize?
    response_type=code&
    client_id=http://localhost:3000/clients/a918F2fs3&
    redirect_uri=httsp://www.example.com/callback&
    scope=write&
    state=2af5D3vds

After the user approves access or chooses not to, we'll redirect to the <tt>redirect_uri</tt> you pass us. If the 
user denies access, an error code is appended:

  https://example.com/callback?access=denied&state=2af5D3vds

If the user approves access will be appended an authorization code in the query string of the URL:

  https://example.com/callback#code=g2VDXwrT0S6iZeUeYQBYi2stxRy&state=2af5D3vds

The client reached through the <tt>redirect_uri</tt> should swap that authorization code for an access token by POSTing 
it along the following params to the token endpoint <tt>http://localhost:3000/oauth/token</tt> using the JSON format.

* <b>code</b> (REQUIRED): authorization code (from the previous step)
* <b>grant_type</b> (REQUIRED): always use "authorization_code" as grant type
* <b>client_id</b> (REQUIRED): client identifier (in our case is the uri field of the client)
* <b>client_secred</b> (REQUIRED): client secret code

Using curl the request might look like:
 
  curl -i http://localhost:3000/oauth/token \
       -H "Accept: application/json" \
       -X POST -d '{
          "code": "g2VDXwrT0S6iZeUeYQBYi2stxRy", \
          "grant_type": "authorization_code", \
          "client_id": "http://localhost:3000/users/alice/client/lelylan", \
          "client_secret": "a34a7afe4731e745de9d61iZeUeY", \
          "scope": "write"
       }'

The response is a JSON Object containing the access token:

  { "access_token":"SlAV32hkKG" }

<b>TODO: add refresh token flow</b>



== OAuth 2.0 for client-side web applications

This flow is meant for JavaScript-based web applications that can't maintain state over time. For those who prefer to send 
and receive HTTP directly without using a client library, this section walks through how to use OAuth 2.0 for client-side 
web applications (it includes also ActionScript and SilverLight).

=== Getting a user's permission

Every flow of OAuth 2.0 begins by sending the user to our OAuth dialog at the authorization endpoint <tt>http://localhost:3000/oauth/authorize</tt>
with the following query parameters

* <b>response_type</b> (REQUIRED): always use "token" as response type
* <b>client_id</b> (REQUIRED): client identifier (in our case is the uri field of the client model)
* <b>redirect_uri</b> (REQUIRED): callback URI to the client application
* <b>scope</b> (REQUIRED): privileges given to the client (TODO: make section)
* <b>state</b> (OPTIONAL): opaque value used by the client to maintain state between the request and callback

Here's an example URL for a hypothetical app called "Example App" running on https://www.example.com

  http://localhost:3000/oauth/authorize?
    response_type=token&
    client_id=http://localhost:3000/clients/a918F2fs3&
    redirect_uri=httsp://www.example.com/callback&
    scope=write&
    state=2af5D3vds

After the user approves access or chooses not to, we'll redirect to the <tt>redirect_uri</tt> you pass. If the 
user denies access, an error code is appended:

  https://example.com/callback#access=denied&state=2af5D3vds

If the user approves will be appended an access token in the hash fragment of the UR:

  https://example.com/callback#token=g2VDXwrT0S6iZeUeYQBYi2stxRy&state=2af5D3vds

JavaScript running on that page can grab that access token from the window.location.hash and either store it in a cookie 
or POST it to a server. Note that the token is added to the {fragment URI}[http://en.wikipedia.org/wiki/Fragment_identifier]. 
This is done because the fragment URI can not be read from server side, but only from client-based applications

<b>TODO: add refresh token flow</b>



== OAuth 2.0 for native applications

This flow is meant for mobile, and desktop installed applications that want access to user data. For those who prefer to send 
and receive HTTP directly without using a client library, this section walks through how to use OAuth 2.0 for native apps.

This flow is suitable in cases where the resource owner has a trust relationship with the client, such as its computer operating 
system or a highly privileged application. The authorization server should take special care when enabling the grant type, and 
<b>only when other flows are not viable</b>, because username and password are given to the client.

=== Getting an access token

The client should POST to the token endpoint <tt>http://localhost:3000/oauth/token</tt> using the JSON format along with the 
following params:

* <b>grant_type</b> (REQUIRED): always use "password" as grant type
* <b>username</b> (REQUIRED): resource owner username
* <b>password</b> (REQUIRED): resource owner password
* <b>client_id</b> (REQUIRED): client identifier (in our case is the uri field of the client model)
* <b>redirect_uri</b> (REQUIRED): callback URI to the client application
* <b>scope</b> (REQUIRED): privileges given to the client (TODO: make section)

Using curl the request might look like:

  curl -i http://localhost:3000/oauth/token \
       -H "Accept: application/json" \
       -X POST -d '{
          "grant_type": "password", \
          "client_id": "http://localhost:3000/users/alice/client/lelylan", \
          "client_secret": "a34a7afe4731e745de9d61iZeUeY", \
          "username": "alice@example.com", \
          "password": "example", \
          "scope": "write"
       }'
       
The response is a JSON Object containing the access token:

  { "access_token":"SlAV32hkKG" }



= Other OAuth2 documentation

If the way OAuth2 works is not clear, you can find great documentation on the web.

* {Oauth2 Specifications}[http://tools.ietf.org/html/draft-ietf-oauth-v2-13]
* {Google OAuth2}[http://code.google.com/apis/accounts/docs/OAuth2.html]
* {Facebook OAuth2}[http://developers.facebook.com/docs/authentication]
* {Gowalla OAuth2}[http://gowalla.com/api/docs/oauth]
* {Foursquare OAuth2}[http://developer.foursquare.com/docs/oauth.html]
* {Instagram OAuth2}[http://instagram.com/developer/auth/]



= Other OAuth2 Ruby Implementations

* {Flowtown Rack OAuth2 Server}[https://github.com/flowtown/rack-oauth2-server]
* {Nov Rack OAuth2}[https://github.com/nov/rack-oauth2]
* {ThoughWorks OAuth2 Provider}[https://github.com/ThoughtWorksStudios/oauth2_provider]
* {Freerange OAuth2 Provider}[https://github.com/freerange/oauth2-provider/blob/master/lib/oauth2/provider/models/access_token.rb]



= Author

Andrea Reginato & The Lelylan Project



= TODOs

* Implement refresh token flow



= Changelog

See CHANGELOG



= License

Rest OAuth2 Server is available under the MIT license.
